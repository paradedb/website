import learnMetadata from "./metadata.json";
import { AuthorSection } from "@/components/AuthorSection";
import { Title } from "@/components/Title";
import { Note } from "@mintlify/components";
import Image from "next/image";

<Title metadata={learnMetadata} />
<AuthorSection metadata={learnMetadata} />

Full-text search (FTS) enables finding documents based on the words they contain rather than just structured fields or metadata. It brings intelligence to text retrieval by analyzing and indexing language, allowing queries to return results ranked by relevance instead of simple matches.

This capability transforms a database from a passive store of records into an information retrieval engine. Rather than forcing users to remember exact values or field names, full-text search lets them describe what they’re looking for in natural terms, and still find it.

## How Full-Text Search Works

Full-text search changes how text is represented so it can query it more effectively. Instead of storing entire documents as opaque blocks that must be scanned linearly, it decomposes them into smaller, searchable parts and rebuilds them into structures optimized for retrieval.

This process begins with text analysis, where raw text is transformed into a form that computers can index efficiently. The pipeline typically includes:

1. Tokenization: Splitting text into discrete terms or tokens, such as words or phrases.
1. Normalization: Lowercasing terms, removing punctuation and stop words, and often applying stemming so that "running," “ran," and “run" are treated as related.
1. Indexing: Storing each token alongside the documents that contain it in a structure called an inverted index that is optimised for answering "which documents contain this word?"

When a user submits a query, the same analysis steps are applied to their search terms, which are then looked up in the index. Algorithms like [BM25](/learn/search-concepts/bm25) score and rank the resulting documents, balancing term frequency, document length, and how rare each term is in the corpus.

Full-text search used these methods to capture linguistic variation, but its focus remains lexical: it matches words, not meanings. For systems that need to also search based on similar sematics a hybrid system that also uses vector search is commonly used.

<Note>
Systems like PostgreSQL, Elasticsearch, and ParadeDB manage this entire pipeline automatically, allowing developers to add high-quality search to their applications without reinventing the underlying mechanics.
</Note>

## Beyond Simple Text Matching

Full-text search provides much more than the ability to find exact matches. It introduces a set of features that make search both flexible and forgiving. This is especially important for real users who misspell words or can’t recall exact phrasing.

- Fuzzy matching corrects small errors and typos, so a query for "databse" still returns “database."
- Phrase search allows users to wrap terms in quotes, finding exact expressions like "machine learning" instead of treating “machine" and “learning" as separate keywords.
- Boolean operators give power users fine-grained control with logic like python AND (api OR web), filtering results to match complex conditions.
- Field weighting acknowledges that some parts of a document matter more than others — a match in a title often carries more importance than one in the body text.

Together, these features make search systems more aligned with human expectations. Users can make mistakes, be imprecise, or mix and match concepts, and still find what they meant to search for.

## Where Full-Text Search Shines

Full-text search becomes essential whenever large volumes of unstructured or semi-structured text need to be queried quickly and intuitively. It thrives in scenarios where users think in terms of language, not schema.

Some common examples include:

- Content discovery: Searching across articles, blog posts, or documentation pages.
- Communication search: Navigating chat histories, emails, or support tickets.
- Technical data exploration: Searching source code, configuration files, or log data for specific patterns.

In these workloads, users aren’t just filtering, they’re searching. They know what they want to find conceptually but not exactly where it’s stored. Full-text search bridges that gap by turning text into a structured, ranked representation of meaning.


## Why Database LIKE Queries Aren’t Enough

Many developers start with LIKE queries for simple search, but the limitations appear quickly.

```sql
SELECT * FROM articles
WHERE title LIKE '%machine learning%
```

This query can only match our exact sequence of characters. It misses relevant variations like "machine-learning techniques" or “learning algorithms for machines."

Using the pipeline discussed above full-text search handles these cases automatically through tokenization, stemming, and normalization. It can match words with similar forms and rank results by importance, rather than by raw text order.

Performance is another major difference. `LIKE` queries require scanning every row, which quickly becomes unmanageable at scale. Full-text search can make use of the inverted indexes to locate matches instantly, returning ranked results in milliseconds even across millions of documents.

## Summary

Full-text search brings lexical structure to unstructured data. By analyzing, indexing, and ranking text, it makes information findable through natural language rather than rigid filters or exact matches.

It remains one of the most effective tools for large-scale text retrieval: fast, reliable, and deeply optimized for keyword relevance.  Its success lies in bridging how people think about information with how computers store it.
