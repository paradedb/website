import learnMetadata from "./metadata.json";
import { AuthorSection } from "@/components/AuthorSection";
import { Title } from "@/components/Title";
import { Note } from "@mintlify/components";
import Image from "next/image";

<Title metadata={learnMetadata} />
<AuthorSection metadata={learnMetadata} />

As an all-purpose database, Postgres has many instances of “decent at this, but better options exist.” One of these cases is full-text search, and in particular, its lack of support for BM25. [BM25](https://www.paradedb.com/learn/search-concepts/bm25)—also stylized as Okapi BM25 or Best Matching 25—is a popular ranking function for document search that targets relevancy. Notably, it’s the ranking function championed by the popular search engine Elasticsearch; Postgres, while supporting basic full-text search, has no native implementation of BM25. 

In this guide, we’ll assume that you are building a Postgres-powered application and discuss the various approaches to implementing BM25. To start, let’s quickly recap how BM25 works. 

## How does BM25 work?

BM25’s goal is to rank the results of a search query by relevancy. 

BM25 considers three variables. The first two are derived from the query’s individual words: (i) the term frequency (TF) of each word and (ii) the inverse document frequency (IDF), which quantifies and weights the rarity of each word. The final variable is the document’s length. By factoring in the document’s length, BM25 can promote shorter documents that might be more centered around the search query. 

In short, BM25 positively weights (i) shorter documents, (ii) those with a high frequency of query words, and (iii) terms that occur more rarely across documents. If you’re curious about the algorithm’s precise mechanics, you can learn more through our [BM25 chapter](https://www.paradedb.com/learn/search-concepts/bm25) in our [Search Concepts](https://www.paradedb.com/learn/search-concepts/full-text-search) collection. 

## Postgres supports full-text search, but not BM25

Despite not supporting BM25, Postgres *does* support full-text search via `ts_rank` and its family of functions. 

Using `ts_rank` and [some set-up work](https://xata.io/blog/postgres-full-text-search-engine#typo-tolerance-fuzzy-search), Postgres developers can implement impressive work-arounds to improve Postgres’s basic full-text search, including popular Elasticsearch features like [faceted search](https://simonwillison.net/2017/Oct/5/django-postgresql-faceted-search) or [typo-tolerance](https://medium.com/@ahmed_aly/typo-tolerant-search-in-rails-combining-ransack-with-postgresqls-pg-trgm-ec544978fe1c). This same approach is used for BM25, where Postgres enthusiasts have previously found ways to implement BM25 [using auxiliary tables](https://www.postgresql.eu/events/pgconfeu2024/sessions/session/6012/slides/592/Di_Qi_LT_BM25.pdf). Today’s developers have it even easier with ParadeDB, an open source batteries-included Postgres database. 

Let’s break apart these various approaches in detail. 

## Routes to implement BM25 in Postgres

There are many ways to implement BM25 in Postgres. Some are significantly more suitable for scaling than others. To begin, let’s start with the most rudimentary (and unscalable) approach: using *just* SQL. 

### Implementing BM25 using just SQL

BM25’s three variables—document length, term frequency, and IDF—could be calculated using Postgres’s conventional count and matching functions. It’ll make for some gnarly looking SQL, but it’s entirely possible. That is … with profound levels of compute and memory.  Because BM25 requires these computations to be calculated for *every word* over the search results, it’s infeasibly slow without some measure of indexing. 

### Implementing BM25 using auxiliary tables

A *slightly* more mature path to implementing BM25 is to use auxiliary tables. With each term occupying a row, index lookups are reduced to a single term per query. Then, these terms could be aggregated with a custom function.

A library that takes this approach is [plpgsql_bm25](https://github.com/jankovicsandras/plpgsql_bm25) by [András Jankovics](https://github.com/jankovicsandras). plpgsql_bm25 implements BM25 using *just* SQL and auxiliary tables. For example, to create an index with plpgsql_bm25, you’d write something like: 

```sql
bm25createindex(tablename TEXT, columnname TEXT, algo TEXT DEFAULT '', stopwordslanguage TEXT DEFAULT '') RETURNS VOID
```

plpgsql_bm25 includes an optional Python implementation that can rank things upwards of 30-40x faster. The library’s Python inclusion isn’t surprising, as SQL + auxiliary tables are still *very* slow. In general, raw Postgres isn’t designed for these “calculate, then aggregate” workflows. Rather, it’s a database oriented around OLTP correctness and flexibility, not number crunching. 

To fix this, we’ll need a more hybridized approach (similar to the aforementioned Postgres talk). The leading Postgres database that takes this path is ParadeDB. 

### Use BM25 on ParadeDB, a Postgres database

ParadeDB is an open-source Postgres database with built-in BM25 search, powered by the `pg_search` extension that’s managed by the ParadeDB team.  The ParadeDB community distribution is free with an optionally paid enterprise variant that targets issues of scale (e.g. larger clusters, physical replication, location replication, and point-in-time recovery).

ParadeDB implements BM25 through [a custom index](https://docs.paradedb.com/welcome/architecture). When a table row is mutated, the BM25 index is immediately altered. This avoids any lag between the *source of truth* and the *search engine*. 

```sql
CREATE INDEX ON dresses USING bm25(id, code, description)
```

ParadeDB’s efficiency could be traced to its underlying memory structure: an LSM tree composed of inverted index and columnar index branches. The branch structure makes ParadeDB extremely efficient for reads, while the tree structure accommodates heavy writes. Additionally, this structure enables parallelization; accuracy boosts aside, the BM25 index significantly outpaces traditional Postgres’s Full-Text Search. 

ParadeDB users could access the BM25 ranking by using the custom operator, `@@@`. For example, results could be ordered (i.e. ranked) by their BM25 scores using the `paradedb.score` function: 

```sql
SELECT id, paradedb.score(id)
FROM dresses
WHERE description @@@ 'floral'
ORDER BY paradedb.score(id)
LIMIT 5;
```

These scores could further be combined for a joint search:

```sql
SELECT o.order_id, paradedb.score(o.order_id) + paradedb.score(m.id) as score
FROM orders o
JOIN dresses d ON o.product_id = d.id
WHERE o.customer_name @@@ 'Sewell' AND d.description @@@ 'floral'
ORDER BY score DESC, o.order_id
LIMIT 5;
```

For developers that aren’t in a position to migrate to a new database, ParadeDB can also be used [as a read replica](https://docs.paradedb.com/deploy/self-hosted/logical-replication/getting-started) of a primary Postgres database, extending BM25 search without altering the main stack. 

## What are the benefits of BM25 support in Postgres?

Thus far, we’ve sidestepped the big question: why would we even want BM25 in Postgres? Especially when products like Elasticsearch exist? 

Simply put: it’s nice to keep things in one place. More specifically, it’s ideal to avoid an ETL pipeline where data needs to be synced from Postgres onto an external search engine, introducing points of failure, increased latency, and the risk of stale content. 

The risk of stale content is especially a problem at scale. Imagine a massive e-commerce platform, such as Wayfair. The platform might need to use BM25 to rank hundreds of results. With BM25, the search bar could surface products with matching descriptions, tags, or titles out of millions of cataloged options. However, with an external, lazily-updated search engine, there’s a significant chance that a popular product that’s gone out-of-stock is recommended. That’s a big problem: the user might bounce to another website in pursuit of the sold-out product. 

When BM25 stays within Postgres, results remain fresh and consolidated. 

## Getting Started with BM25 in Postgres

If you want to get started with BM25 in Postgres, the easiest path is to consider ParadeDB. If you already have a Postgres instance, consider using ParadeDB as a read-replica or directly installing `pg_search` using the ParadeDB Dockerfile. Alternatively, if you are looking for a more hands-on plugin for performance-agnostic needs, then something like [plpgsql_bm25](https://github.com/jankovicsandras/plpgsql_bm25) might be a suitable option.  

