import learnMetadata from "./metadata.json";
import { AuthorSection } from "@/components/AuthorSection";
import { Title } from "@/components/Title";
import { Note } from "@mintlify/components";
import Image from "next/image";

<Title metadata={learnMetadata} />
<AuthorSection metadata={learnMetadata} />

PostgreSQL offers two primary approaches for implementing full-text search: the built-in full-text search capabilities and ParadeDB's pg_search, a PostgreSQL extension that brings modern search engine capabilities to your database. Both approaches embrace PostgreSQL's strengths while offering different feature sets and complexity levels.

Understanding the differences between these approaches helps you choose the right solution for your search requirements and operational constraints.

## Built-In PostgreSQL Full-Text Search

PostgreSQL's native search converts text into searchable mathematical representations using a pipeline of text processing steps:

- **Text parsing:** documents are broken into lexemes (meaningful units)
- **Stemming:** "running," "runs," and "ran" are treated as the same concept
- **Stop word removal:** common words like "the," "and," "of" are filtered out
- **Language support:** built-in configurations for multiple languages

### Core Data Types

PostgreSQL uses two specialized data types for search:

- **`tsvector`:** processed, searchable version of your text
- **`tsquery`:** search criteria in optimized format

```sql
-- Convert text to searchable format
SELECT to_tsvector('english', 'The quick brown fox jumps');
-- Result: 'brown':3 'fox':4 'jump':5 'quick':2

-- Create a search query
SELECT to_tsquery('english', 'quick & fox');
-- Result: 'quick' & 'fox'

-- Search for matches
SELECT title FROM articles
WHERE to_tsvector('english', content) @@ to_tsquery('english', 'database & optimization');
```

The `@@` operator tests matches, while functions like `ts_rank()` calculate relevance scores based on term frequency and proximity.

**Advantages:**

- No additional dependencies or extensions required
- Fully transactional with ACID guarantees
- Integrates seamlessly with existing SQL queries
- Mature and stable implementation
- Built-in language configurations and stemming
- Good performance for basic search needs

**Limitations:**

- Limited to PostgreSQL's built-in text processing
- Basic relevance scoring compared to modern search engines
- No advanced features like fuzzy matching or faceted search
- Requires separate tsvector columns or functions for different search scopes
- Performance degrades with search-heavy workloads

## ParadeDB Extension

ParadeDB brings modern search engine capabilities to PostgreSQL by implementing advanced indexing and scoring algorithms while maintaining PostgreSQL's transactional guarantees.

### How ParadeDB Works

ParadeDB uses specialized index types (like BM25) that provide more sophisticated text analysis and scoring. It includes all the same text processing capabilities as PostgreSQL's built-in search (tokenization, stemming, stop word removal) plus advanced features:

```sql
-- Create a BM25 index with ParadeDB covering multiple columns
CREATE INDEX articles_search_idx ON articles
USING bm25(title, content) WITH (key_field='id');

-- Search across all indexed columns (like PostgreSQL but with BM25)
SELECT id, title, paradedb.score(id) as relevance
FROM articles
WHERE articles @@@ 'database optimization'
ORDER BY relevance DESC;

-- Query specific columns within the same index
SELECT id, title, paradedb.score(id) as relevance
FROM articles
WHERE articles @@@ 'title:database OR content:optimization'
ORDER BY relevance DESC;
```

**Advantages:**

- **All built-in PostgreSQL features:** tokenization, stemming, stop words, language support
- **Advanced relevance scoring:** BM25 instead of basic tf-idf
- **Enhanced text analysis:** configurable tokenization pipelines per column
- **Modern search features:** fuzzy matching, phrase queries, boolean logic
- **Superior performance:** significantly faster for search-heavy workloads
- **Flexible indexing:** multi-column indexes with individual column querying and boosting
- **Query optimization:** complex search queries executed directly in the index
- **Full PostgreSQL integration:** maintains ACID guarantees and transactional consistency

**Limitations:**

- Requires extension installation and maintenance

<Note>
  Both approaches maintain PostgreSQL's ACID guarantees and transactional
  consistency, although ParadeDB can also be deployed as a logical follower to a
  standard PostgreSQL node.
</Note>

## Choosing Between Approaches

### When to Use Built-In Full-Text Search

Native PostgreSQL search works well when:

- **Simplicity is prioritized:** no additional dependencies or extensions
- **Basic search needs:** standard text matching with basic relevance scoring
- **Small to medium datasets:** performance is adequate for your data size
- **Standard text processing:** built-in stemming and language support are sufficient

```sql
-- Built-in search with complex SQL operations
SELECT p.name, p.price, ts_rank(to_tsvector(p.description), query) as rank
FROM products p, to_tsquery('laptop & gaming') query
WHERE to_tsvector(p.description) @@ query
  AND p.price BETWEEN 500 AND 2000
ORDER BY rank DESC;
```

### When to Use ParadeDB

ParadeDB is better suited for:

- **Search-heavy workloads:** applications with frequent, complex search queries
- **Superior relevance:** need BM25 scoring instead of basic tf-idf
- **Search-focused applications:** search quality is a primary concern
- **Large datasets:** need performance optimizations for scale
- **Advanced text processing:** configurable tokenization and analysis pipelines
- **Multi-column flexibility:** index multiple columns together but query them separately
- **Modern search features:** fuzzy matching, phrase queries, field-specific searching

```sql
-- ParadeDB search with advanced scoring
SELECT p.name, p.price, paradedb.score(p.id) as rank
FROM products p
WHERE p @@@ 'laptop gaming~2' -- fuzzy matching
  AND p.price BETWEEN 500 AND 2000
ORDER BY rank DESC;
```

## Feature Comparison

| Feature                   | Built-In Search                    | ParadeDB                                        |
| ------------------------- | ---------------------------------- | ----------------------------------------------- |
| **Setup Complexity**      | None (built-in)                    | Requires extension installation                 |
| **Text Processing**       | Tokenization, stemming, stop words | Same + configurable pipelines                   |
| **Query Syntax**          | `@@` operator, `tsquery`           | `@@@` operator, Lucene-style queries            |
| **Relevance Scoring**     | tf-idf with `ts_rank()`            | BM25, semantic similarity                       |
| **Language Support**      | Built-in configurations            | Built-in + enhanced analyzers                   |
| **Fuzzy Matching**        | Limited                            | Advanced fuzzy search with `~`                  |
| **Performance**           | Good for moderate datasets         | Significantly faster for search-heavy workloads |
| **Multi-column Indexing** | Separate tsvector per search scope | Single BM25 index, query columns individually   |
| **Maintenance**           | Standard PostgreSQL                | Extension updates and management                |
| **Transactional**         | Full ACID compliance               | Full ACID compliance                            |

## Implementation Examples

### Built-In Search Setup

```sql
-- Create a table with built-in search
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  title TEXT,
  content TEXT,
  search_vector tsvector
);

-- Update search vector when content changes (applies tokenization, stemming, stop words)
UPDATE documents SET search_vector =
  to_tsvector('english', coalesce(title,'') || ' ' || coalesce(content,''));

-- Create GIN index for fast searching
CREATE INDEX documents_search_idx ON documents USING GIN(search_vector);

-- Search documents with tf-idf relevance scoring
SELECT title, ts_rank(search_vector, query) as rank
FROM documents, to_tsquery('english', 'postgresql & search') query
WHERE search_vector @@ query
ORDER BY rank DESC;

-- Boolean queries supported
SELECT title FROM documents
WHERE search_vector @@ to_tsquery('english', 'database & (optimization | performance)');
```

### ParadeDB Setup

```sql
-- Enable ParadeDB extension
CREATE EXTENSION pg_search;

-- Create table (no need for separate tsvector column)
CREATE TABLE documents (
  id SERIAL PRIMARY KEY,
  title TEXT,
  content TEXT
);

-- Create single BM25 index covering multiple columns (applies same tokenization, stemming, stop words)
CREATE INDEX documents_search_idx ON documents
USING bm25(title, content) WITH (key_field='id');

-- Search across all columns with BM25 relevance scoring
SELECT id, title, paradedb.score(id) as rank
FROM documents
WHERE documents @@@ 'postgresql search'
ORDER BY rank DESC;

-- Query specific columns within the same index
SELECT id, title, paradedb.score(id) as rank
FROM documents
WHERE documents @@@ 'title:postgresql OR content:search'
ORDER BY rank DESC;

-- Advanced features: fuzzy matching and phrase queries
SELECT id, title, paradedb.score(id) as rank
FROM documents
WHERE documents @@@ 'postgresql~2 AND "search engine"'
ORDER BY rank DESC;
```

## Making the Choice

**Start with built-in search** if you need simple, reliable text search without additional dependencies. PostgreSQL's native capabilities handle most common search scenarios effectively.

**Consider ParadeDB** when you need advanced search features, better relevance scoring, or are building search-focused applications where query quality significantly impacts user experience.

Both approaches keep your search capabilities within PostgreSQL, maintaining transactional consistency and eliminating the complexity of external search infrastructure. The choice depends on balancing feature requirements against operational complexity.
